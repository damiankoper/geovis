\chapter{Wizualizacje}

Rozdział ten opisuje obiekty wizualizacji, które powstały podczas rozwoju komponentu Silnika. Ich opis będzie postępował w~kolejności od najprostszych, do tych bardziej skomplikowanych, których te prostsze stanową podstawę. Opisane zostaną również bardziej złożone aspekty renderowania grafiki, jeśli wizualizacje z~takich korzystają.
Wizualizacje te są po części demonstracją możliwości Silnika i~nie były tworzone z~zachowaniem stuprocentowej dokładności odwzorowania zjawisk.

\section{Gwiazdy}

Wizualizacja ta wyświetla teksturę kosmosu nałożoną na wewnętrzną część sfery - rysunek~\ref{fig:c4_starsVis}. Kamera znajduje się w~jej środku, więc przeciągnięcie widoku w~jedną stronę skutkuje przesunięciem się tekstury kosmosu w~przeciwną. Wizualizacja ta nie modyfikuje ustawień kamery oraz nie definiuje swojego panelu kontrolnego. Tekstura gwiazd pochodzi ze strony \url{https://www.solarsystemscope.com/}~\cite{SolarTextures}. 

\begin{figure}[h]
  \centering
  \includegraphics[width=\linewidth]{img/c4_starsVis.png}
  \caption{Wizualizacja gwiazd - klasa \texttt{StarsVis}}
  \label{fig:c4_starsVis} 
\end{figure}

Na listingu~\ref{lst:starsVis} pokazano część klasy \texttt{StarsVis} definiującą tę wizualizację. Sfera tworzona jest z~użyciem klasy \texttt{THREE.SphereGeometry}, a~jej materiał \texttt{THREE.MeshBasicMaterial} zawiera ustawienia definiujące jej wyświetlanie. Ustawienie \mbox{\texttt{side:THREE.BackSide}} sprawia, że teksturowane są odwrotna niż zwykle strona rysowanego trójkąta. Ustawienia \mbox{\texttt{depthWrite:false}} oraz \mbox{\texttt{depthFunc:THREE.NeverDepth}} sprawiają, że obiekt nie będzie wpływał na wartość z-bufora, oraz będzie rysowany zawsze za innymi obiektami, co jest oczekiwane od obiektu tła. 


\begin{lstlisting}[float, language=javascript, label={lst:starsVis}, caption={
  Fragmenty klasy \texttt{StarsVis}}
]
/* ... */
export default class StarsVis extends Visualization {
private stars = new THREE.SphereGeometry(40000, 10, 10);
private starsMaterial = new THREE.MeshBasicMaterial({
  side: THREE.BackSide,
  map: new THREE.TextureLoader().load(starsMap),
  depthWrite: false,
  depthFunc: THREE.NeverDepth,
});
private mesh = new THREE.Mesh(this.stars, this.starsMaterial);
/* ... */
public setupCamera(camera: TrackballCamera): void {
  //
}
public setupScene(scene: THREE.Scene, group: THREE.Group): void {
  this.mesh.renderOrder = 0;
  group.add(this.mesh);
}
public update(deltaFactor: number): void {
  this.mesh.rotation.y = TimeService.getHourAngle();
}
/* ... */
}
\end{lstlisting}

Obiekt 3D \texttt{THREE.Mesh} w~metodzie \texttt{update} obracany jest w~osi $OY$ o~pewien kąt. Kąt ten wynika z~czasu słonecznego, ponieważ wizualizacja ta domyślnie ma stanowić tło dla wizualizacji Ziemi w~czasie rzeczywistym. Może być ona również rozszerzona, aby obsługiwać każdy inny dowolny czas. Kiedy kamera jest nieruchowa względem punktu na Ziemi, jej obrót w~okół własnej osi widoczny jest jako obrót tła w~przeciwnym kierunku. Klasa TimeService, dokładniej opisana w~dalszej części pracy, zawiera metodę \texttt{getHourAngle}, która dla danej strefy czasowej oblicza kąt obrotu Słońca od danej długości geograficznej o~danym czasie~\cite{SolarTime}. Punktem odniesienia jest południk $\ang{0}$ i~strefa czasowa \textit{+00:00}. 

\section{Atmosfera}

Wizualizacja atmosfery stanowi wizualną dekorację dla innych wizualizacji. Składa się ona z~dwóch osobno generowanych części. Wizualnie atmosfera to poświata widoczna nad powierzchnią planety, która zanika wraz ze wzrostem wysokości punktu nad powierzchnią. Na efekt też wpływa sama grubość atmosfery, jej skład chemiczny, oraz gęstość w~poszczególnych jej partiach.

Utworzona wizualizacja nie posiada rozbudowanych możliwości konfiguracji i~została stworzona do współpracy z~wizualizacją Ziemi w~dużej skali. Na efekt poświaty składają się dwa obiekty. Pierwszym jest sfera, której średnica odpowiada średnicy planety razem z~grubością atmosfery. Wyświetlana jest jej wewnętrzna część i~znając pozycje obserwatora, wyświetlana jest właściwie zanikająca poświata. Drugim obiektem jest sfera rozmiarów planety, która zawsze generowana jest przed nią i~odpowiada za poświatę widoczną bezpośrednio nad planetą. Na rysunku~\ref{fig:c4_atmosphereVis} przedstawiono efekt atmosfery bez planety. Istotne są tutaj jedynie krawędzie widocznego okręgu, ponieważ jego środek ukryty będzie za planetą. Na rysunku~\ref{fig:atmosphere} przedstawiono schemat elementów kluczowych dla wyliczenia parametrów atmosfery. Kamera znajduje się w~punkcie $c_l$. Okrąg rysowany linią ciągłą symbolizuje powierzchnię planety, a~linią przerywaną, zasięg atmosfery. Wektor $\vv t$ stanowi przedłużenie wektora $\vv{g_v}$ o~grubość atmosfery. Widoczny dla obserwatora fragment atmosfery jest łukiem pomiędzy punktami $c_{gtb}$~i~$c_{gt}$.

\begin{figure}
\centering
\includegraphics[width=\linewidth]{img/c4_atmosphereVis.png}
\caption{Wizualizacja atmosfery - klasa \texttt{AtmosphereVis}}
\label{fig:c4_atmosphereVis} 
\end{figure}

\begin{figure}[h]
\centering
\input{drawings/atmosphere.tex}
\caption{Schemat elementów kluczowych dla wyliczenia parametrów atmosfery}
\label{fig:atmosphere}
\end{figure}

\begin{lstlisting}[float, language=javascript, label={lst:atmosphereVis}, caption={
Fragmenty klasy \texttt{StarsVis}}
]
public atmosphereMaterial = new THREE.ShaderMaterial({
vertexShader: vertexShader,
fragmentShader: fragmentShader,
uniforms: {
  start: { value: 1 },
  stop: { value: 0.6 },
  fadeOut: { value: 0 },
  light: { value: 0 },
  power: { value: 1.25 },
  glowColor: { value: new THREE.Color(0x87ceeb) },
  viewVector: { value: new THREE.Vector3() },
  ...THREE.UniformsLib.lights,
},
depthFunc: THREE.NeverDepth,
lights: true,
transparent: true,
side: THREE.BackSide,
depthWrite: false,
});
\end{lstlisting}

Na listingu~\ref{lst:atmosphereVis} przedstawiono inicjalizację materiału odpowiedzialnego za poświatę nad planetą. Klasa \texttt{THREE.ShaderMaterial} pozwala kontrolować cały proces rysowania punktów, ponieważ wymaga dostarczenia obydwu typów shaderów. Tak jak w~przypadku materiału w~wizualizacji \texttt{StarsVis}, materiał definiuje też ustawienia modyfikacji z-bufora i~strony wyświetlanego trójkąta. Materiał definiuje również stałe dla jednego procesu rysowania (\texttt{uniforms}). Stałe te są aktualizowane w~każdym cyklu animacji. 
W procesie rysowania poświata generowana jest w~zależności od kąta pomiędzy wektorem normalnym płaszczyzny dla wierzchołka, a~wektorem określającym kierunek obserwacji. Niżej opisano stałe przekazywane do materiału.

\subsubsection{Uniform \texttt{start}}
Uniform \texttt{start} to ułamek liczby $\pi$ w~zakresie $\lbrack0; 1\rbrack$, który stanowi kąt wektora obserwatora z~wektorem normalnym wierzchołka, od którego rozpoczyna się rysowanie poświaty. Wartość ta zawsze wynosi $1$, co oznacza, że poświata rysowana jest od wierzchołków najdalej od kamery. Jego wektor normalny na rysunku \ref{fig:atmosphere} oznaczony został symbolem $\vv n$. Kąt między nim, a~wektorem $\vv{g_v} + \vv{l_v}$ wynosi $\ang{180}$, czyli $1 \cdot \pi$.

\subsubsection{Uniform \texttt{stop}}
Uniform \texttt{stop} to ułamek liczby $\pi$ w~zakresie $\lbrack0; 1\rbrack$, który stanowi kąt wektora obserwatora z~wektorem normalnym wierzchołka, od którego kończy się rysowanie poświaty o~pełnej przezroczystości. Ostatnim widocznym z~kamery punktem jest punkt $c_{gtb}$. Dalsza część schowana jest za planetą. Kąt ten wyliczany jest z~zależności $\beta+\gamma$. Sposób wyliczenia poszczególnych kątów pokazano na równaniach~\ref{eq:atm_beta}~i~\ref{eq:atm_gamma}.

\begin{align}
  \label{eq:atm_alfa}
  \alpha &= acos(\frac{\length{\vv{g_v}+\vv{t}}}{\length{\vv{g_v}+\vv{l_v}}}) \\
  \label{eq:atm_beta}
  \beta &= acos(\frac{\length{\vv{g_v}}}{\length{\vv{g_v}+\vv{l_v}}}) \\
  \label{eq:atm_gamma}
  \gamma &= acos(\frac{\length{\vv{g_v}}}{\length{\vv{g_v}+\vv{t}}})
\end{align}


\subsubsection{Uniform \texttt{fadeOut}}
Uniform \texttt{fadeOut} to ułamek liczby $\pi$ w~zakresie $\lbrack0; 1\rbrack$, który stanowi kąt wektora obserwatora z~wektorem normalnym wierzchołka, od którego kończy się rysowanie poświaty o~zanikającej przezroczystości. Jest ona interpolowana z~wykorzystaniem funkcji wygładzającej \texttt{expoIn}, którą pokazano na wykresie na rysunku~\ref{fig:c4_expoIn}. Kąt ten wyliczany jest z~zależności $\beta+\gamma-\alpha$.
\begin{figure}[h]
  \centering
  \begin{tikzpicture}[scale=0.7]
      \begin{axis}[domain=0:1,xmin=0,xmax=1.1,ymin=0,ymax=1.1,xlabel=$t$, ylabel=$f(t)$, legend pos=north west, width=0.6\textwidth, height=0.5\textwidth]
          \addplot[blue, ultra thick] {pow(2, 10 * x - 10)};
          \addlegendentry[text depth=2.5ex]{
              $f(t) = 
              \begin{cases}
                0 & \text{dla } t = 0\\
                2^{10 \cdot t - 10} & \text{dla } t > 0
              \end{cases}
              $
          };
      \end{axis}
  \end{tikzpicture}
  \caption{Funkcja wygładzająca \textit{expoIn}}
  \label{fig:c4_expoIn}
\end{figure}
\subsubsection{Uniform \texttt{light}}
Uniform \texttt{light} to ułamek liczby $\pi$ w~zakresie $\lbrack0; 1\rbrack$, który stanowi kąt przesunięcia oświetlanej powierzchni dla światła. Jeśli do sceny zostanie dodane światło kierunkowe to wpływa ono na wygląd atmosfery. W~normalnej sytuacji światło kierunkowe oświetla dokładnie pół sfery. Załóżmy sytuację, w~której kąt padania światła wyznacza wektor rozciągnięty pomiędzy punktami $c'_g$~i~$c_{gtb}$. W~takiej sytuacji atmosfera oświetlona by była na łuku pomiędzy wektorami $\vv {g'''_v}$~i~$\vv {g'_v} + \vv{t'_v}$. Żeby oświetlić pozostałą, widoczną część atmosfery (łuk pomiędzy punktami $c_{gtb}$~i~$c_{gt}$) w~obliczeniach, trzeba uwzględnić kąt $\gamma$.

\subsubsection{Uniform \texttt{power}}
Uniform \texttt{power} to wykładnik potęgi, do której podniesiona zostaje finalna przezroczystość materiału atmosfery, przed kalkulacją oświetlania. Wartość ta nie jest aktualizowana i~wynosi $1.25$.

\subsubsection{Uniform \texttt{glowColor}}
Uniform \texttt{glowColor} to bazowy kolor materiału atmosfery. Nie ulega on zmianie i~ma wartość \texttt{0x87ceeb}. Możliwą poprawą zachowania atmosfery byłaby dynamiczna zmiana koloru atmosfery powiązana z~kątem padania światła, co symulowałoby zmianę koloru w~miejscach zachodu i~wschodu słońca.

\subsubsection{Uniform \texttt{viewVector}}
Uniform \texttt{viewVector} to wektor jednostkowy skierowany od środka $s$ grupy obrotu do kamery $c_l$. Odpowiada on za orientację wyświetlanej atmosfery zawsze w~kierunku punktu, w~którym znajduje się kamera. Uzyskanie wektora przed normalizacją przedstawiono na równaniu~\ref{eq:c4_atm_1}.
\begin{equation}
  \label{eq:c4_atm_1}
  \vv v = q^{-1}([0, 0, \length{\vv{g_v}}]^T + \vv{l_v})q
\end{equation}
\begin{eqexpl}[25mm]
\item {$\vv v$} wektor \texttt{viewVector}
\item {$q$} kwaternion uzyskany z~macierzy układu odniesienia wizualizacji. W~równaniu obrót następuje w~kierunku odwrotnym.
\end{eqexpl}
\vspace{\baselineskip}


Uniform \texttt{fadeOut} bierze też udział w~ujednoliceniu koloru nieba, kiedy kamera schodzi poniżej granicy atmosfery. Zachowanie to nie zostało jednak wystarczająco rozwinięte, żeby odzwierciedlać realistycznie przejście pomiędzy czernią kosmosu, a~niebieskim niebem z~użyciem tego samego materiału w~procesie rysowania. Pozostałe stałe w~opisywanym materiale są uzupełnieniem z~obiektu \mbox{\texttt{THREE.UniformsLib.lights}}. Zawierają one dane związane ze światłami obecnymi na scenie. 

Materiał opisujący wygląd drugiej sfery, atmosfery widocznej nad ziemią, ma podobną budowę, korzysta z~wyliczonych kątów i~podobnych mechanizmów. Biorąc to pod uwagę, nie zostanie on tutaj opisany. 

\section{Ziemia}

Opisane wcześniej wizualizacje gwiazd i~atmosfery pozwalają na stworzenie wizualizacji planety. Wizualizacja \texttt{EarthVis} jest wizualizacją planety Ziemi, która prezentuje jej aktualne oświetlenie przez Słońce. Widok początkowy wizualizacji przedstawiono na rysunku~\ref{fig:c4_earthVis_1}. 


\begin{figure}[h]
  \centering
  \includegraphics[width=\linewidth]{img/c4_earthVis_1.png}
  \caption{Widok początkowy wizualizacji Ziemi o~godzinie 19:50, 27.09.2020r.}
  \label{fig:c4_earthVis_1} 
\end{figure}
  

\begin{figure}[h]
  \centering
  \includegraphics[width=\linewidth]{img/c4_earthVis_2.png}
  \caption{Zachód słońca nad Europą o~godzinie 18:54, 27.07.2020r.}
  \label{fig:c4_earthVis_2} 
\end{figure}
  
Podczas każdej aktualizacji animacji obliczane jest nowe położenie słońca. Poruszając się w~układzie odniesienia Ziemi konieczne jest obliczenie deklinacji Słońca, czyli kąta pomiędzy nim, a~płaszczyzną równika~\cite{Declination}. Drugą wartością konieczną do wyliczenia jest kąt godzinny~\cite{SolarTime}. Jest to kąt, o~jaki obróciło się Słońce od wybranego punktu odniesienia dla wybranej strefy czasowej w~konkretnej chwili. Wizualizacja Ziemi stanowi podstawę do wizualizacji połączonych z~nią zjawisk dużej skali. Bazują na niej wizualizacje \texttt{ActiveSatellitesVis} oraz \texttt{IssVis} opisane w~dalszej części pracy. Na rysunku~\ref{fig:c4_earthVis} przedstawiono diagram zależności pomiędzy poszczególnymi wizualizacjami i~klasami pomocniczymi.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{diagrams/out/c4_earthVis.png}
  \caption{Zależności pomiędzy klasami wizualizacji Ziemi}
  \label{fig:c4_earthVis} 
\end{figure}

Na wizualizację składają się wszystkie obiekty ustawiane przez wizualizacje \texttt{AtmosphereVis} i~\texttt{StarsVis}. Na scenie w~układzie współrzędnych wizualizacji znajdują się dwie sfery. Pierwsza z~nich odpowiada za wyświetlanie tekstury Ziemi, a~druga, z~promieniem większym o~$4$~km, wyświetla chmury. Materiał pierwszej sfery implementuje model oświetlania z~cieniowaniem Phonga~\cite[Rozdział 3]{RealTime3DGraphics} za pomocą obiektu \texttt{THREE.MeshPhongMaterial} i~używa czterech map.
\begin{enumerate}
  \item \texttt{map} - mapa zawierająca kolor tekseli tekstury dziennej
  \item \texttt{nightMap} - mapa zawierająca kolor tekseli tekstury nocnej
  \item \texttt{specularMap} - mapa zawierająca poziom odbicia kierunkowego światła dla każdego teksela tekstury
  \item \texttt{normalMap} - mapa zawierająca wektory normalne w~przestrzeni stycznej wierzchołka modelu.
\end{enumerate}

Materiał sfery wyświetlające chmury zawiera tylko mapę definiującą sam kolor tekseli. Jako, że ta mapa jest obrazem chmur na czarnym tle i~nie zawiera kanału \texttt{alpha}, materiał w~procesie renderowania stosuje mieszanie addytywne. Grupa obrotu zawiera również światło kierunkowe, które zawsze skierowane jest do jej środka. Pozycja źródła światła obracana jest zgodnie z~wartościami wyliczonymi przez serwis \texttt{TimeService}, kolejno o~kąt godzinny w~osi~$OY$ i~deklinację w~osi~$OX$.

Na rysunku~\ref{fig:c4_earthVis_2} pokazane zostało płynne przejście pomiędzy teksturą nocną i~dzienną, która jest wyświetlana w~zależności od oświetlenia planety. Zachowanie to wymagało zmodyfikowania domyślnego fragment shadera i~uzależnienia wyświetlanej tekstury od kąta pomiędzy interpolowanym wektorem normalnym dla teksela, a~kierunkiem padania światła. Na listingu~\ref{lst:earthFrag} pokazano najważniejszą część modyfikacji shadera. Potrzebny kąt wyliczany jest z~wykorzystaniem iloczynu skalarnego wspomnianych wektorów. Wynik ten musi być zmapowany z~przedziału $\lbrack-1; 1\rbrack$ na przedział $\lbrack0; 1\rbrack$. Obliczenie wartości, która trafia do funkcji wygładzającej, a~następnie do funkcji \texttt{mix}, która miesza wartości tekseli, pokazano na równaniu~\ref{eq:earth_dot}.

\begin{lstlisting}[float=h, language=C++, label={lst:earthFrag}, caption={
  Modyfikacja fragment shadera materiału \texttt{MeshPhongMaterial}}
]
#if NUM_DIR_LIGHTS > 0
  float dotL =  dot(vNormal, directionalLights[0].direction);
  vec4 texelColorNight = texture2D( nightMap, vUv );
  texelColorNight = mapTexelToLinear( texelColorNight );

  outgoingLight = mix(
    vec3(texelColorNight) + ambientLightColor,
    outgoingLight,
    easeInOutExpo(dotL*0.5+0.5)
  );
#endif
\end{lstlisting}
\begin{equation}
  \label{eq:earth_dot}
  x = (\vv{n} \cdot \vv{d}) \cdot 0.5 + 0.5
\end{equation}
\begin{eqexpl}[25mm]
\item {$\vv n$} wektor normalny
\item {$\vv d$} kierunek padania światła
\item {$x$} wartość w~przedziale $\lbrack0; 1\rbrack$
\end{eqexpl}
\vspace{\baselineskip}

Wizualizacje dostarcza również panel kontrolny, który pokazany został na rysunku~\ref{fig:c3_controls_earth} i~pozwala na przełączanie się pomiędzy trybami kamery - swobodnym i~kompas.

\section{Wybrane satelity}

Wizualizacją stworzoną na podstawie wizualizacji Ziemi jest wizualizacja wybranych satelitów orbitujących wokół niej. Klasą definiującą tę wizualizację jest klasa \texttt{IssVis} obecna na rysunku~\ref{fig:c4_earthVis}. Znajdują się na nim również klasy wspomagające wyświetlanie i~wyliczanie pozycji obiektów. Na scenie znajdują się trzy satelity. Są nimi Międzynarodowa Stacja Kosmiczna, Kosmiczny Teleskop Hubble'a oraz Eutelsat Hot Bird 13C. Każda satelita reprezentowana jest za pomocą trzech obiektów, którymi jest elipsa reprezentująca kształt orbity, obiekt satelity będący złożonym modelem 3D lub sferą oraz linia łącząca obiekt satelity ze środkiem planety.  Wizualizacja dostarcza komponent panelu kontrolnego, który umożliwia zmianę trybu pracy kamery oraz zarządzenie widocznością poszczególnych satelitów. Pozycja satelitów wyświetlana jest w~czasie rzeczywistym, a~ich pozycja i~orbita kalkulowana jest z~wykorzystaniem danych w~formacie TLE~(ang.~Two-Line Elements).

\subsection{TLE}
TLE jest formatem zapisu informacji o~satelicie pozwalającym wyznaczyć z~dużym przybliżeniem jej pozycję relatywnie do ciała orbitowanego~\cite{TLE}. Pierwsza linia zawiera nazwę satelity i~może być pomijana w~zapisie. Druga linia jednoznacznie identyfikuje satelitę i~zawiera informacje o~punkcie w~czasie, dla którego określone są parametry orbity - epokę. Zawiera również informacje kontrolne o~samym TLE oraz pierwszą i~drugą pochodną prędkości ruchu. Trzecia linia zawiera parametry orbity. Najważniejszymi z~nich są inklinacja, kąt węzła wstępującego, ekscentryczność i~argument perycentrum, który dla Ziemi nazywa się argumentem perygeum. Poniżej przedstawiono przykładowe dane dla Międzynarodowej Stacji Kosmicznej.
\begin{verbatim}
ISS (ZARYA)
1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927
2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537
\end{verbatim}

W stworzonej wizualizacji TLE pobierane są ze strony CelesTrak~\cite{CelesTrak}, która zbiera i~analizuje dane otrzymane od jednostki NORAD (ang. North American Aerospace Defense Command). Dane otrzymywane są w~formacie tekstowym. Serwis \texttt{TLEService} odpowiedzialny jest za pobranie danych TLE wszystkich aktywnych satelitów, sparsowanie je, a~następnie wyemitowanie zdarzenia \texttt{onUpdate}, które może być obsłużone w~procesie inicjalizacji obiektów na scenie. Serwis ten umożliwia również dostęp do danych satelity z~wykorzystaniem jej identyfikatora. Dla satelitów, na których pozycję wpływać może atmosfera i~inne nieregularne czynniki, dane TLE mogą z~czasem stawać się nieaktualne. Dzieje się to jednak na przestrzeni dni. Założyć można, że pobranie najnowszej ich wersji w~momencie uruchamiania wizualizacji pozwala na wystarczająco dokładne wyliczenia ich pozycji.

Za obliczenie parametrów orbity, wygenerowanie obiektów sceny i~odpowiednią transformację ich pozycji odpowiada obiekt \texttt{SatelliteObject} reprezentujący pojedynczą satelitę. Oblicza on parametry elipsy i~generuje reprezentujący ją obiekt klasy \texttt{THREE.EllipseCurve}. Równania~\ref{eq:sat_1}~-~\ref{eq:sat_3} opisują proces wyliczenia parametrów orbity. Wyliczenia półosi wielkiej $a$ wynika z~trzeciego prawa Kelpera, które łączy jej długość zależnością z~okresem obiegu satelity wokół Ziemi, który to dostarcza TLE. Transformacja aktualizowana jest w~każdym przebiegu pętli animacji.

\begin{samepage}
  \begin{figure}[h]
  \begin{align}
      \label{eq:sat_1}
      a~&= \frac{G^{\frac{1}{3}}}{(\frac{2n\pi}{86400})^{\frac{2}{3}}} \\
      \label{eq:sat_2}
      b &= a\sqrt{1-e^2} \\
      \label{eq:sat_3}
      c &= e \cdot a
  \end{align}
  \begin{eqexpl}[25mm]
      \item {$a$} półoś wielka orbity
      \item {$G$} standardowy parametr grawitacyjny Ziemi
      \item {$n$} średnia liczba obiegów Ziemi w~ciągu 24 godzin
      \item {$b$} półoś mała orbity
      \item {$e$} ekscentryczność orbity
      \item {$c$} przesunięcie od środka do ogniska orbity
  \end{eqexpl}
  \vspace{\baselineskip}
\end{figure}
\end{samepage}

Finalna transformacja obiektu elipsy jest z~złożeniem obrotów i~translacji. Najpierw wykonywana jest translacja elipsy tak, aby środek Ziemi pokrywał się z~jej ogniskiem. Następnie w~osi $OX$ elipsa obracana jest o~kąt wynikający z~danych o~inklinacji orbity.  Potem wykonywany jest obrót w~osi $OY$ o~kąt wynikający z~położenia punktu Barana, czyli punktu służącego do orientacji w~odniesieniu do równikowego układu współrzędnych oraz ekliptyki. W~tej samej osi elipsa obracana jest o~kąt wynikający z~kąta węzła wstępującego oraz o~kąt przeciwny do kąta godzinnego, aby uwzględnić obrót Ziemi w~czasie. Na końcu następuje obrót uwzględniający argument perygeum. 

Funkcja \texttt{TimeService.getFirstPointOfAriesAngle} odpowiedzialna jest za obliczanie kąta od punktu Barana. W~obecnej implementacji może ona jednak być czynnikiem wpływającym na brak pokrycia orientacji orbity w~osi $OY$ z~jej faktyczną trajektorią. Sztuczna korekcja staje się również nieaktualna po jakimś czasie. Autor wizualizacji nie był w~stanie dostatecznie zbadać przyczyny tego problemu. 

Za obliczanie pozycji samej satelity na orbicie odpowiada biblioteka \texttt{tle.js}~\cite{tle.js}, która jest używana w~procesie aktualizacji obiektu \texttt{SatelliteObject}. Pozwana ona, na postawie TLE, uzyskać położenie satelity o~podanym czasie. Etykiety generowane są z~użyciem obiektu \texttt{THREE.Sprite}, który wyświetla kwadratową teksturę zawsze zorientowaną w~kierunku obserwatora. Tekstura jest napisem, który rysowany jest dynamicznie na elemencie \texttt{Canvas} przetworzonym przez obiekt \texttt{THREE.CanvasTexture}. Rozmiar etykiet jest wprost proporcjonalny do odległości obiektu od obserwatora. Zachowanie to utrzymuje taki sam rozmiar etykiet niezależnie od orientacji kamery na scenie.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{img/c4_issVis.png}
  \caption{Wybrane satelity - klasa \texttt{IssVis}}
  \label{fig:c4_issVis} 
\end{figure}

\section{Aktywne satelity}

Wizualizacja, którą opisuje klasa \texttt{ActiveSatellitesVis}, która pokazana jest na rysunku~\ref{fig:c4_earthVis}, wyświetla wszystkie aktywne satelity na podstawie danych ze strony CelesTrak~\cite{CelesTrak}. Widok początkowy wizualizacji przedstawia za pomocą punktów pozycje satelitów w~chwili obecnej. Wizualizacja dostarcza panel kontrolny, dzięki któremu można zmienić tryb ruchu kamery oraz przyspieszyć upływ czasu. Można dzięki temu zobaczyć przybliżoną pozycję satelitów w~przyszłości. Panel kontrolny posiada również możliwość resetu czasu wizualizacji do chwili obecnej. Na rysunku~\ref{fig:c4_activeSatellitesVis} pokazana została wizualizacja oraz jej panel kontrolny. Widać na nim dobrze łuk, którą tworzą satelity na orbicie geostacjonarnej.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{img/c4_activeSatellitesVis.png}
  \caption{Aktywne satelity - klasa \texttt{ActiveSatellitesVis}}
  \label{fig:c4_activeSatellitesVis} 
\end{figure}

Podobnie jak w~przypadku wizualizacji opisanej klasą \texttt{IssVis} dane TLE pobierane są i~zarządzane poprzez klasę \texttt{TLEService}. Kalkulacja pozycji satelitów również wykonywana jest z~użyciem mechanizmów klasy \texttt{SatelliteObject}. Różnicą pomiędzy tymi wizualizacjami jest to, że klasa \texttt{SatelliteObject} nie tworzy i~nie dodaje do sceny obiektów reprezentujących satelity. 

\begin{lstlisting}[float, language=javascript, label={lst:active1}, caption={
  Fragmenty klasy \texttt{ActiveSatellitesVis}}
]
private pointsMaterial = new THREE.PointsMaterial({
  transparent: true,
  color: 0xffffff,
  size: 5,
  sizeAttenuation: false,
});
private points = new THREE.Points(
  new THREE.BufferGeometry(),
  this.pointsMaterial
);

public update(deltaFrac: number) {
  /* ... */
  const points: number[] = [];
  this.sateliteObjects.forEach((o) => {
    const p = o.getPosition(this.timestamp);
    points.push(p.x, p.y, p.z);
  });
  this.points.geometry.setAttribute(
    "position",
    new THREE.BufferAttribute(new Float32Array(points), 3)
  );
  /* ... */
}
\end{lstlisting}

Dostępne dane zawierają informacje o~około 8000 aktywnych satelitów. Wywołanie polecenia rysowania dla każdego punktu oddzielnie skutkowałoby długim czasem rysowania, ponieważ w~procesie generowania grafiki najwięcej czasu tracone jest na komunikacji z~GPU. Dlatego wizualizacja wywołuje tylko jedno polecenie rysowania dla wszystkich punktów. Listing~\ref{lst:active1} zawiera inicjalizację obiektu materiału \texttt{THREE.PointsMaterial} oraz obiektu \texttt{THREE.Points} odpowiedzialnego za reprezentację punktów na scenie. Inicjalizowany jest on z~pustym buforem reprezentującym pozycje wierzchołków. Rola buforów w~procesie rysowania opisana została w~rozdziale~\ref{sec:render}. W~pokazanej na listingu~~\ref{lst:active1} metodzie \texttt{update}, wykonywanej co każde przejście pętli głównej, bufor uzupełniany jest nowymi współrzędnymi punktów. Wszystkie punkty rysowane są za pomocą jednego polecenia, a~rysowanie każdego z~osobna dzieje się równolegle w~GPU. Największy narzut obliczeniowy spowodowany jest kalkulacją pozycji w~obiektach \texttt{SatelliteObject}, który przy dużych liczbach jest już dostrzegalny.

\section{Kafelki i~Radar pogodowy}

Wizualizacja, którą opisuje klasa \texttt{OsmTiles}, przedstawia Ziemię, na którą nałożono wiele warstw tekstur. Pierwszą z~nich jest mapa przeglądowa powierzchni, drugą jest pokrycie terenu zasięgiem radarów meteorologicznych, a~trzecią z~nich jest wizualizacja danych z~owych radarów w~danej chwili. Szczegółowość mapy zależy od przybliżenia kamery. Wizualizacja składa się z~wcześniej opisanych wizualizacji gwiazd oraz atmosfery. Nie zawiera ona dynamicznego oświetlenia, a~światło kierunkowe znajduje się w~układzie odniesienia obserwatora, zawsze oświetlając widoczną stronę planety.

Panel kontrolny dostarczony przez wizualizację pozwala na zmianę trybu pracy kamery, na zmianę widocznych warstw oraz na zmianę czasu dla wizualizowanych opadów. Wizualizacja pozwala również na animację warstwy opadów, pozwalając na zaobserwowanie ich dynamiki w~ostatnim czasie. Na rysunkach~\ref{fig:c4_osmTilesVis}~oraz~\ref{fig:c4_osmTilesVis_1} przedstawiono mapy w~małej i~średniej skali.
\begin{figure}[h]
  \centering
  \includegraphics[width=\linewidth]{img/c4_osmTilesVis.png}
  \caption{Opady deszczu nad Europą - klasa \texttt{OsmTilesVis}}
  \label{fig:c4_osmTilesVis} 
\end{figure}

\begin{figure}[h]
  \centering
  \includegraphics[width=\linewidth]{img/c4_osmTilesVis_1.png}
  \caption{Opady deszczu nad Polską - klasa \texttt{OsmTilesVis}}
  \label{fig:c4_osmTilesVis_1} 
\end{figure}

\subsection{Kafelki}
Kafelki są sposobem reprezentacji danych mapy. Pozwalają na optymalizację jej wyświetlania, ponieważ dzielą obszar na niezależne fragmenty, z~których można skomponować pożądany widok. Dzięki nim można pobierać te dane, które aktualnie są potrzebne. Kafelki mogą być dowolnymi danymi, które mapują pewne wartości na powiązane z~nimi pozycje na mapie. W~przypadku opisu wyglądu obiektów na mapie mogą występować w~postaci grafiki wektorowej jak i~rastrowej.

W celu odwzorowania powierzchni Ziemi na płaską grafikę zaszła potrzeba dobrania odpowiedniej metody jej projekcji. Odwzorowanie walcowe równokątne, zwane odwzorowaniem Merkatora jest metodą projekcji, w~której kąty pomiędzy równoleżnikami i~południkami są zachowane. Wszystkie południki na mapie są równoległe do siebie, a~co za tym idzie, odwzorowanie to na biegunach dąży do nieskończoności. Web Merkator~\cite{Mercator} to modyfikacja odwzorowania Merkatora wykorzystywana przez zdecydowaną większość map dostępnych w~internecie. Od swojego pierwowzoru różni się tym, że obszar mapowany jest na powierzchni sfery, a~nie tak jak pierwotnie, na elipsoidzie. Projekcja ta nie odwzorowuje też terenu dla szerokości geograficznej większej od~$\ang{85.051129}$. Pozwala to na umieszczenie odwzorowanego terenu na kwadratowej powierzchni. Pojedynczy kafelek rastrowy zwykle jest kwadratem o~boku $256$ pikseli.

Kafelki generowane są dla różnych poziomów szczegółowości, co skutkuje różną wymaganą do ich wyświetlenia rozdzielczością przyjmując ten sam punkt odniesienia. Aby zachować stały rozmiar kafelka, kolejne poziomy szczegółowości zawierają odpowiednio więcej kafelków. Aby ujednolicić poruszanie się po kafelkach wprowadzono system współrzędnych, który jednoznacznie identyfikuje kafelek. Powiązanie kafelków ze współrzędnymi geograficznymi ich lewego górnego rogu opisane zostało za pomocą równań~\ref{eq:tile_1}~-~\ref{eq:tile_2}. Z~równań tych wynika, że dla przybliżenia $z = 0$ mapa składa się z~jednego kafelka. Liczba kafelków $n$, z~których składa się mapa, w~zależności od przybliżenia $z$ opisana może zostać zależnością $n = 2^{2z}$.

\begin{samepage}
  \begin{figure}[h]
  \begin{align}
      \label{eq:tile_1}
      x &= \left\lfloor \frac{lon + 180}{360} \cdot 2^z \right\rfloor \\
      \label{eq:tile_2}
      y &=
          \left\lfloor
              \left(
                  1 - \frac{
                      \ln \left(
                          \tan \left(
                              lat \cdot \frac{\pi}{180}
                          \right) + \frac{1}{\cos \left( lat \cdot \frac{\pi}{180} \right)}
                      \right)
                  }{\pi}
              \right) \cdot 2^{z - 1}
          \right\rfloor
  \end{align}
  \begin{eqexpl}[25mm]
      \item {$x$} pozycja odpowiadająca długości geograficznej
      \item {$lon$} długość geograficzna w~stopniach
      \item {$y$} pozycja odpowiadająca szerokości geograficznej
      \item {$lat$} szerokość geograficzna w~stopniach
      \item {$z$} stopień szczegółowości (przybliżenia)
  \end{eqexpl}
  \vspace{\baselineskip}
\end{figure}
\end{samepage}

\subsection{Implementacja}

Wizualizacja, pobierając potrzebne dane kafelków, korzysta z~domyślnego zestawu warstw map OpenStreetMap~\cite{OSM}. Dane dotyczące radaru i~deszczu udostępniane są przez aplikację RainViewer~\cite{RainViewer}. Kafelki z~obu tych źródeł udostępniane są w~tym samym, pożądanych formacie. Na diagramie na rysunku~\ref{fig:c4_tiles} przedstawiono klasę \texttt{TilesService} oraz jej zależności, która odpowiedzialna jest za generowanie i~zarządzanie geometrią sceny związanej z~kafelkami. Wywołanie konstruktora tej klasy, pokazane na listingu~\ref{lst:tilesVis_1}, zawiera przekazany obiekt konfiguracji, który zawiera metodę zwracającą adres URL kafelka dla pożądanej pozycji i~przybliżenia, ustawienie widoczności i~filtry CSS, modyfikujące oryginalny wygląd pobranej grafiki.

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.7]{diagrams/out/c4_tiles.png}
  \caption{Zależności pomiędzy klasami wizualizacji \texttt{OsmTilesVis}}
  \label{fig:c4_tiles} 
\end{figure}

\begin{lstlisting}[float=h, language=javascript, label={lst:tilesVis_1}, caption={
  Fragmenty klasy \texttt{OsmTilesVis}}
]
/* ... */
this.osmTilesService = new TilesService(
    [
      {
        tileUrl: (x, y, z) =>
          `https://tile.openstreetmap.org/${z}/${x}/${y}.png`,
        visible: true,
        filter: "brightness(60%)",
      },
      {
        tileUrl: (x, y, z) =>
          `https://tilecache.rainviewer.com/v2/coverage/0/256/${z}/${x}/${y}.png`,
        visible: true,
        filter: "opacity(10%)",
      },
      {
        tileUrl: (x, y, z) =>
          `https://tilecache.rainviewer.com/v2/radar/${
            this.timestamps[this.timestampIndex]
          }/256/${z}/${x}/${y}/4/1_1.png`,
        visible: true,
        filter: "opacity(60%)",
      },
    ],
    100
  );
/* ... */
\end{lstlisting}

Każdy kafelek jest wycinkiem sfery, za którego utworzenie odpowiada konstruktor klasy \texttt{THREE.SphereGeometry}. Wygenerowana geometria może być współdzielona dla każdego kafelka na tej samej szerokości geograficznej i~z tym samym przybliżeniem, dlatego serwis \texttt{TileService} zapisuje raz wygenerowaną geometrię do map, których kluczami są współrzędne~$y$~i~$z$ kafelków. W~przypadku ponownego użycia kafelków dla tych współrzędnych ich geometria pobierana jest z~mapy. Serwis ten definiuje również metody przeliczające długość i~szerokość geograficzną na współrzędne~$x$~i~$y$ dla określonego przybliżenia $z$. Definiuje też przekształcenie odwrotne.

Kafelki tworzą strukturę drzewiastą. Korzeniem drzewa jest kafelek o~współrzędnych $(x, y, z) = (0,0,0)$. Po zwiększeniu przybliżenia dzielony jest on na cztery mniejsze kafelki o~współrzędnych $(0,0,1)$, $(1,0,1)$, $(0,1,1)$ i~$(1,1,1)$. Każdy kafelek w~drzewie może posiadać czterech potomków. Drzewo kafelków rozwijane jest w~sposób możliwie optymalny, a~wyświetlane są zawsze kafelki będące liśćmi tego drzewa. Nie ma potrzeby rozwijać poddrzewa kafelków dla obszaru będącego po drugiej stronie planety, ponieważ nie jest on widoczny. Nie ma również potrzeby wyświetlania kafelków wysokiej rozdzielczości na horyzoncie, ponieważ znajdując się daleko, wyświetlane są one z~użyciem mniejszej ilości pikseli, a~co za tym idzie, wymagają mniejszej dokładności. Serwis \texttt{TilesService} zawiera instancję klasy \texttt{TileTreeNode} reprezentującej węzeł drzewa, który w~tym przypadku jest jego korzeniem. Węzeł drzewa odpowiedzialny jest za generowanie swoich potomków oraz niszczenie samego siebie i~rysowanie swojej tekstury.

Drzewo analizowane jest pod kątem pożądanego stopnia szczegółowości $z$. W~rekurencyjnym rozwijaniu drzewa brana jest pod uwagę odległość kafelka od kafelka, nad którym znajduje się kamera w~metryce taksówkowej na tym samym poziomie szczegółowości oraz kąt pod jakim kamera spogląda na kafelek. Im większa owa odległość i~kąt, tym rozwijanie kafelków zakończy się wcześniej, nie osiągając danego stopnia $z$ w~obszarach, które nie są ważne z~perspektywy generowanego widoku. Działanie to jest główną metodą optymalizacji wyświetlanych kafelków. Rozwinięte wcześniej węzły drzewa, których stopień szczegółowości jest większy niż pożądany, są niszczone. Przykładowe rozwinięcie węzłów drzewa pokazano na diagramie na rysunku~\ref{fig:c4_tilesTree}. Liście oznaczone kolorem czerwonym są wyświetlane. Działanie w~praktyce zaobserwować można na rysunku~\ref{fig:c4_osmTilesVis_custom}, gdzie wszystkie kafelki zawierają grafikę z~ich współrzędnymi. Na horyzoncie widać wyświetlane kafelki z~mniejszym poziomem szczegółowości. 

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.4]{diagrams/out/c4_tilesTree.png}
  \caption{Przykładowe rozwinięcie drzewa kafelków}
  \label{fig:c4_tilesTree} 
\end{figure}

\begin{figure} 
  \centering
  \includegraphics[width=\linewidth]{img/c4_osmTilesVis_custom.png}
  \caption{Rozwinięcie drzewa kafelków - testowe kafelki}
  \label{fig:c4_osmTilesVis_custom} 
\end{figure}

Na obiekt kafelka w~procesie rysowania nałożona zostaje dynamicznie tekstura. Pochodzi ona z~obiektu \texttt{Canvas}, który obsługiwany jest przez obiekt \texttt{THREE.CanvasTexture}. Pobieranie obrazów, ich późniejsze dekodowanie i~późniejsza kompozycja warstw w~jedną teksturę kafelka wymaga pewnej mocy obliczeniowej. Przy mapie złożonej z~dużej liczby kafelków czynności te, jeśli zajmowałby się nimi wątek główny JavaScriptu, mogą stanowić obciążenie dla urządzenia wyświetlającego wizualizację. Kod wykonujący się domyślnie w~przeglądarce internetowej może wykonać się tylko w~jednym wątku. Aby wprowadzić możliwość akceleracji obliczeń dla zadań, które mogą wykonywać się w~tle i~nie mają nic wspólnego z~interfejsem użytkownika, stworzone zostały Web~Workery~\cite{Workers}. W~celu rozwiązania problemu bezpieczeństwa w~komunikacji pomiędzy wątkami, workery korzystają ze ściśle określonego interfejsu. Nie współdzielą one między sobą pamięci, którą można przekazywać jedynie w~jedną stronę poprzez operację transferu. Sama komunikacja opera się na zdarzeniach, których dane są serializowane i~deserializowane na styku wątków. Aby odciążyć główny wątek w~procesie rysowania sceny, operacje pobierania i~kompozycji kafelków odbywają się w~workerze, czyli całkowicie niezależnie od głównej pętli animacji.

Klasa \texttt{TilePainter} reprezentuje obiekt workera. Standardowy obiekt \texttt{Canvas} jest elementem DOM, do którego nie ma dostępu w~workerach, ponieważ nie kontrolują one interfejsu użytkownika. Na potrzeby rysowania grafik w~tle zaproponowano interfejs \texttt{OffscreenCanvas}~\cite{OffscreenCanvas}, który zachowuje się dokładnie tak jak element \texttt{Canvas} dostępny w~głównym wątku.

Kiedy użytkownik zmieni widoczność warstwy lub przesunie kamerę pokazując nowe kafelki, wywołane zostają zdarzenia, które po przejściu przez mechanizm \texttt{throttle} wywołują przeliczenie drzewa kafelków. Każdy kafelek, jeśli nigdy nie miał wygenerowanej tekstury lub jeśli wymagania co do wyglądu tekstury uległy zmianie, wysyła, poprzez serwis \texttt{TilesService}, zdarzenie do workera \texttt{TilePainter}. Następnie worker pobiera wymagane kafelki z~ich źródeł i~nakłada je na siebie wykorzystując zdefiniowane filtry. W~zdarzeniu zwrotnym obiekt bitmapy zostaje przetransferowany do wątku głównego i~tam narysowany na elemencie \texttt{Canvas} tekstury z~użyciem szybkiego kontekstu \texttt{bitmaprenderer}. Worker, w~celu zaoszczędzenia pamięci i~transferu sieciowego, prowadzi cache już narysowanych kafelków i~omija proces pobierania i~kompozycji, jeśli kafelek został już wcześniej przetworzony.

Obiekty wygenerowanej geometrii wycinków sfer reprezentujących kafelki są przekształcane po wygenerowaniu. Obiekt przesuwany jest tak, że jego centroid znajduje się w~środku układu współrzędnych. Następnie, w~definiowanej dla niego macierzy przekształcenia, oprócz obrotu o~kąt wynikający z~długości geograficznej kafelka, to przesunięcie jest odwracane. Działanie to ma na celu zniwelowanie efektu zatracenia precyzji w~procesie przetwarzania wierzchołków przez procesor graficzny. Wierzchołki zdefiniowane daleko od środka układu współrzędnych obarczone są większym błędem związanym z~funkcjonowaniem liczb zmiennoprzecinkowych. Rozmiar liczby dla typu \texttt{Number} w~języku JavaScript wynosi 64b, a~procesor graficzny standardowo przetwarza współrzędne zapisane za pomocą liczb o~rozmiarze 32b. Dla większych liczb, w~procesie wyliczania finalnej pozycji wierzchołka, występuje zanik precyzji spowodowany operacją mnożenia. Zdecydowanie lepiej zdefiniować obiekt z~pozycją blisko środka układu współrzędnych, przekształcić go, a~następnie wykonać translację na jego finalną pozycję. Translacja, jako operacja dodawania, nie zaburza precyzji.

\section{Podsumowanie}

Wizualizacje opisane wcześniej i~obecne jako przykłady w~komponencie Silnika są prezentacją możliwości, jakich dostarcza zaproponowany przez projekt sposób definicji wizualizacji. Opisanie wizualizacji przez pojedynczą klasę, która rozszerza klasę bazową z~dobrze udokumentowanym interfejsem pozwala na bezpośrednią ingerencję kodu w~kształt sceny. System, będąc z~założenia systemem wyświetlającym scenę trójwymiarową, może być użyty do definiowania wizualizacji hybrydowych, gdzie dane z~warstw 2D mogą być nakładane i~wyświetlane na trójwymiarowej powierzchni~\cite{Hybrid}. Atrakcyjna prezentacja danych powiązanych z~punktami na mapie może również obejmować generowanie trójwymiarowych wykresów.

Łatwo konfigurowalny panel kontrolny wykorzystywany może być do sterowania wyglądem wizualizacji. Przez bezpośrednie połączenie z~interfejsem sterowania kamerą, jak i~samą wizualizacją, może być używany do pokazywania i~ukrywania warstw danych, do zmiany położenia kamery, czy do sterowania animacją upływu czasu dla wizualizowanych zjawisk. Przykładem może być dynamika wzrostu zachorowań na COVID-19, czy też zobrazowanie wzorców przemieszczania się ludzi dla różnych pór dnia~\cite{Kwan}.

Oddanie pełnej kontroli nad wizualizacją daje możliwość swobodnej optymalizacji wyświetlanej sceny, a~mechanizmy przetwarzania danych w~innym wątku, oraz asynchroniczne pobieranie niezbędnych zasobów daje możliwość operacji na wielkich zbiorach danych wyświetlając jedynie interesujące odbiorcę w~danej chwili fragmenty z~odpowiednią precyzją, mając na uwadze, że grafika generowana jest w~środowisku przeglądarki internetowej. Z~dużymi możliwościami przychodzi jednak duża odpowiedzialność. To od twórcy zależy jak jego wizualizacja będzie się zachowywać w~kontekście wydajności i~interakcji z~użytkownikiem.

Komponent Silnika, definiując tylko zachowanie kamery i~podstawowe założenia definicji wizualizacji pozwala na utworzenie kolejnych warstw abstrakcji. Możliwe jest na przykład utworzenie w~pełni konfigurowalnego systemu wyświetlającego dane dostarczone w~postaci kafelków, który jest dużo bardziej zaawansowany niż ten opisany w~przykładowej wizualizacji. Może obsługiwać on wiele formatów kafelków, rastrowe oraz wektorowe. Może również pozwalać na nałożenie warstw trójwymiarowych, na dodanie interesujących statystyk w~postaci wykresów lub etykiet, czy też na morphing kafelków dla danych w~czasie. Wszystko sprowadza się do stworzenia przetestowanego podsystemu, który będzie udostępniony i~wykorzystany przez innych twórców. 